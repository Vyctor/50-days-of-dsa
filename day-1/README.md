# Day 1

## How to make best use of this course

- Do not miss a day. Maintain the consistency
- Try to solve by yourself before looking at the solution
- Don't skip coding the solution
- Go in order. Some aspects of the course are discussed in order.
- If you know a topic use 2x

## Goals of day one

Welcome to Day 1 of the DSA Coding Challenge:

Today's Goals (Arrays) :

-Learn Big O Analysis to find Time and Space complexity

-Array Data Structure Crash Course

Question 1: Sorted Squared Array - You are given an array of Integers in which each subsequent value is not less than the previous value. Write a function that takes this array as an input and returns a new array with the squares of each number sorted in ascending order.

Question 2: Monotonic Array - An array is monotonic if it is either monotone increasing or monotone decreasing. An array is monotone increasing if all its elements from left to right are non-decreasing. An array is monotone decreasing if all  its elements from left to right are non-increasing. Given an integer array return true if the given array is monotonic, or false otherwise.

## What are data structures

- Collection of data values with Relationships among them and Function/operations that can be applied on
- Data structures are used to store and organize data in a computer so that it can be used efficiently

### Why do we need data structures to ace coding interviews?

We need them to solve problems efficiently. Data structures help us to store and organize data in a computer so that it can be used efficiently. They are essential to solve complex problems and to improve the performance of our code.

## Introduction to Big O, Time Complexity

Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. It is a member of a family of notations invented by Paul Bachmann, Edmund Landau, and others, collectively called Bachmann–Landau notation or asymptotic notation.

### Why do we need Big O?

Big O notation is used in Computer Science to describe the performance or complexity of an algorithm. Big O specifically describes the worst-case scenario, and can be used to describe the execution time required or the space used (e.g. in memory or on disk) by an algorithm.

### What is Time Complexity?

Time complexity is a concept in computer science that deals with the quantification of the amount of time taken by a set of code or algorithm to process or run as a function of the amount of input. **It is a way to show how the runtime of an algorithm grows as the size of the input grows.**

## Whats is Assintotic Analysis?

Asymptotic analysis is the big idea that handles above issues. It is a method of describing limiting behavior. It is an analysis of an algorithm that focuses on the running time of the algorithm as the input size tends to infinity. It is a way to show how the runtime of an algorithm grows as the size of the input grows.

### Types of Asymptotic Analysis

- Best Case
- Average Case
- Worst Case

### Big O Notation

Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. It is a member of a family of notations invented by Paul Bachmann, Edmund Landau, and others, collectively called Bachmann–Landau notation or asymptotic notation.

#### Common Time Complexities

- O(1) - Constant Time
- O(log n) - Logarithmic Time
- O(n) - Linear Time
- O(n log n) - Linear Logarithmic Time
- O(n^2) - Quadratic Time
- O(2^n) - Exponential Time
- O(n!) - Factorial Time
- O(n^n) - Exponential Time
- O(n^3) - Cubic Time
- O(n^k) - Polynomial Time

## Big O Space Complexity

Space complexity is a measure of the amount of working storage an algorithm needs. That is the amount of memory space required by the algorithm to execute a program and produce output. It is a way to show how the space required by an algorithm grows as the size of the input grows.
**Is how much auxiliary memory do we need to allocate in order to run the algorithm.**

### Common Space Complexities

- O(1) - Constant Space
- O(log n) - Logarithmic Space
- O(n) - Linear Space
- O(n log n) - Linear Logarithmic Space
- O(n^2) - Quadratic Space
- O(2^n) - Exponential Space
- O(n!) - Factorial Space
- O(n^n) - Exponential Space
- O(n^3) - Cubic Space
- O(n^k) - Polynomial Space

## Big O - Logarithmic Time Complexity

log 16 on base 2 = 4 and 2^4 = 16 so if
log 8 on  base 2 so 2^? = 8 ? = 3 so log 8 on base 2 = 3

Logarith time complexity is a very efficient time complexity. It is even better than linear time complexity. It is the inverse of exponential time complexity. It is the time complexity of algorithms that cut the problem in half each time.

## Data Structures Crash Course

### Big O Common Array Operations

- Access - O(1)
- Set - O(1)
- Traverse/Search - O(n)
- Copy - O(n)
- Insert
  - At beginning - O(n)
  - At end - O(1)
  - Some other position - O(n)
- Remove
  - At beginning - O(n)
  - At end - O(1)
  - Some other position - O(n)
